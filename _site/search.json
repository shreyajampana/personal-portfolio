[
  {
    "objectID": "clinic/index.html",
    "href": "clinic/index.html",
    "title": "Clinic/Capstone Projects",
    "section": "",
    "text": "During my junior year, I worked with Trilobio, a biotech startup developing modular robotic systems for laboratory automation, as part of Harvey Mudd’s Clinic program. Trilobio’s robots (Trilobots) automate tasks like multichannel pipetting, but currently rely on manual validation of dispensed volumes. Our team was tasked with designing a precision analytical balance capable of validating up to eight pipetted samples simultaneously, integrating directly into Trilobio’s modular robotic platform. Automating this process has the potential to save researchers significant time, improve reproducibility, and lower barriers to accessible lab automation.\nMechanically, our design relied on a flexure-based system, where the deflection of a beam under load is converted into a measurable signal. A novel damping system and custom housing stabilized the measurements against vibration and environmental noise, providing bothstructural support and electromagnetic shielding. Custom weigh boats were also designed to integrate with our balance.\nMy primary focus was on the electrical system, which enabled precise mass measurement through capacitive sensing. I designed custom PCBs (one of which is shown on the left) that integrated capacitive plates, high-resolution capacitance-to-digital converters, and signal conditioning circuitry. I also helped implemented digital communication through I²C multiplexing and integrated an STM32 microcontroller with CAN bus capabilities to ensure seamless communication with the Trilobot system. To minimize noise, I separated analog and digital domains on the PCB, carefully routed signals, and incorporated shielding into the design.\nIn addition to PCB design, I contributed to testing and debugging the electronic system. This included calibrating the capacitive sensors, validating resolution down to sub-milligram precision, and characterizing sources of noise under different housing and damping configurations. Our final three-channel prototype demonstrated the ability to measure dispensed liquid volumes with the required precision in low-noise environments and provided a clear roadmap for scaling to a full eight-channel system.\nThis project gave me hands-on experience in precision electronics, PCB design, and noise mitigation, while also exposing me to the interdisciplinary challenges of integrating mechanical flexures, damping, and custom housings with high-resolution electrical sensing. More broadly, it strengthened my ability to bridge theory with practice, working within real-world constraints to deliver a system that could be directly integrated into a commercial robotic platform. Below are two photos from our site visit, one of which is me troubleshooting/resoldering our PCB, and the other of which features my fantastic team!"
  },
  {
    "objectID": "clinic/index.html#trilobio",
    "href": "clinic/index.html#trilobio",
    "title": "Clinic/Capstone Projects",
    "section": "",
    "text": "During my junior year, I worked with Trilobio, a biotech startup developing modular robotic systems for laboratory automation, as part of Harvey Mudd’s Clinic program. Trilobio’s robots (Trilobots) automate tasks like multichannel pipetting, but currently rely on manual validation of dispensed volumes. Our team was tasked with designing a precision analytical balance capable of validating up to eight pipetted samples simultaneously, integrating directly into Trilobio’s modular robotic platform. Automating this process has the potential to save researchers significant time, improve reproducibility, and lower barriers to accessible lab automation.\nMechanically, our design relied on a flexure-based system, where the deflection of a beam under load is converted into a measurable signal. A novel damping system and custom housing stabilized the measurements against vibration and environmental noise, providing bothstructural support and electromagnetic shielding. Custom weigh boats were also designed to integrate with our balance.\nMy primary focus was on the electrical system, which enabled precise mass measurement through capacitive sensing. I designed custom PCBs (one of which is shown on the left) that integrated capacitive plates, high-resolution capacitance-to-digital converters, and signal conditioning circuitry. I also helped implemented digital communication through I²C multiplexing and integrated an STM32 microcontroller with CAN bus capabilities to ensure seamless communication with the Trilobot system. To minimize noise, I separated analog and digital domains on the PCB, carefully routed signals, and incorporated shielding into the design.\nIn addition to PCB design, I contributed to testing and debugging the electronic system. This included calibrating the capacitive sensors, validating resolution down to sub-milligram precision, and characterizing sources of noise under different housing and damping configurations. Our final three-channel prototype demonstrated the ability to measure dispensed liquid volumes with the required precision in low-noise environments and provided a clear roadmap for scaling to a full eight-channel system.\nThis project gave me hands-on experience in precision electronics, PCB design, and noise mitigation, while also exposing me to the interdisciplinary challenges of integrating mechanical flexures, damping, and custom housings with high-resolution electrical sensing. More broadly, it strengthened my ability to bridge theory with practice, working within real-world constraints to deliver a system that could be directly integrated into a commercial robotic platform. Below are two photos from our site visit, one of which is me troubleshooting/resoldering our PCB, and the other of which features my fantastic team!"
  },
  {
    "objectID": "clinic/index.html#ohmium",
    "href": "clinic/index.html#ohmium",
    "title": "Clinic/Capstone Projects",
    "section": "Ohmium",
    "text": "Ohmium\nDuring my senior year, as a part of Harvey Mudd’s Clinic Program, our project is sponsored by Ohmium. Ohmium develops Proton Exchange Membrane (PEM) Electrolyzers, which are electrochemical devices that use a special polymer membrane to split water into hydrogen and ozygen using electrocity. This green hydrogen solution reduces the carbon needed in many industrial and energy processes, thus promoting a more sustainable way of life.\nPEM electrolyzers use catalysts to enhance the reaction rates and efficiency. Due to lack of predictive capabilities, catalyst performance must be evaluated in the actual device, and since tests can range up to a multitude of hours, this presents a limitation to rapid development. Our clinic team is tasked with solving this problem, and our goal is to design a testing system that is capable of testing multiple materials/catalyst mixes in a single experiment. This project requires a deep understanding of PEM cells and functionalities, as well as an interdisciplinary team of mechanical, electrical, and computer/controls engineers. We are currently in the process of designing and building this system, and I am focusing primarily on the electrical subsystem of this project. Stay tuned to hear about our final solution!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shreya Jampana",
    "section": "",
    "text": "ENGINEERING @ HARVEY MUDD COLLEGE\n\nHi! I’m a senior engineering student passionate about combining my technical and theoretical skills to develop novel solutions to engineering problems. I have a strong foundation in electrical engineering, with a special emphasis and interest in analog and RF systems. I also have experience in digital design and microprocessor-based systems.\nWith my general engineering education, I love working across disciplines, integrating electrical, mechanical, and computational approaches to create innovative and robust designs. I’m especially motivated by projects that drive meaningful impact, from advancing technologies in the biotech space to supporting environmental sustainability."
  },
  {
    "objectID": "uPs/lab4.html",
    "href": "uPs/lab4.html",
    "title": "Shreya Jampana's Portfolio",
    "section": "",
    "text": "In this lab, I learned how to use my MCU to play music by using timers. These timers generated square waves by toggling a GPIO pin at a specific frequency for specified durations. This lab also served as an introduction to working with the STM32 microcontroller boards. I gained a lot of experience with reading proper documentation (reference manual and datasheet) to understand clocks, timers, register, I/O, and more. The end result consisted of playing “Fur Elise” and my chosen song of “Hedwig’s Theme” from Harry Potter!\n\n\n\n\n\nI used the Timer 15 and Timer 16 registers in order to output a square wave signal from the microcontroller. For this lab, we had to read the datasheet carefully and write our own library in C from scratch. One of the reasons I chose Timers 15 and 16 is because they have the same register map. This meant I could take advantage of only having to write one struct in my timer header file. Another reason I chose these timers is that they both have the ability to be configured to a PWM mode and be connected to a GPIO pin in alternate function mode in order to have the desired functionality of producing a square wave output.\nAfter writing my header file, I wrote my timer source code, which consisted of four functions: initTIM to initialize my timer, delay_millis to provide a millisecond delay to set my note durations, initPWM to initialize the PWM mode of Timer 16, and setFreq to set the square wave to the desired frequency. Writing these four functions was the most difficult part of the lab, as they consisted of hours reading the reference manual to understand configuration, registers, and precisely which bits to set in which order to produce the desired functionality.\n\n\n\nTo go into more details on how the timers work, the timer configured in the PWM mode had the auto reload register (ARR) and the capture/compare register (CCR1) set in order to produce a specific period and duty cycle. The ARR value is set such that when the counter is equal to this value, it resets to 0, meaning this value sets the period of the signal. When the counter is less than the CCR1 value, it outputs a low (0), and when the counter is higher, it outputs a high (1), meaning the CCR1 value sets teh duty cycle. I set the CCR1 value to be half of the ARR value to have a duty cycle of 0.5. For the timer configured to set the delay, I utilized the ARR to control the delay, as it was set depending on the millisecond input.\nIn this lab, I used a phase-locked-loop (PLL) to set the microcontroller clock at 80 MHz, and to produce lower frequencies, I used prescalers. The timing calculations and theory behind my prescaler values are shown below in Figure 1.\n\n\n\nFigure 1. Timing calculations for frequency of sound output\n\n\nIn order to make sure that the minimum and maximum frequency and duration were supported with my chosen prescaler values, I did the calculations shown below in Figure 2.\n\n\n\nFigure 2. Max and min duration and frequency calculations\n\n\nOne of the specs for this lab was to produce individual pitches calculated to be accurate within 1% across the frequency range of 220-1000 Hz. Using the derived formula in figure 1 and careful unit conversion, I ran a timing analysis across this frequency range to make sure the spec was met. The calculations used to program the spreadsheet, showing examples of the pitches and durations being correct, as well as the resulting data is shown below in Figure 3 and 4, respectively.\n\n\n\nFigure 3. Calculations for spreadsheet and examples\n\n\n\n\n\nFigure 4. Pitch accuracy spreadsheet\n\n\n\n\n\nIn order to test the software’s functionality first, I uploaded the code to my MCU and used an oscilloscope to read the values of the GPIO pin to check that I was seeing the correct duty cycle and frequency. There was a lot of troubleshooting here, as I originlly did not see any square waves. I used Segger’s built in Debug mode to step through my code and ensure that all my registers were getting the value they were supposed to. After debugging and changing the way I configured/enabled things in my code, I started to see the correct frequency square waves in the oscilloscope.\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe circuit for this lab was simple. It contained an LM386 audio amplifier to drive the 8 ohm speaker and a potentiometer for volume control. The schematic is shown below in Figure 5.\n\n\n\nFigure 5. Schematic for audio amplifier circuit\n\n\n\n\n\n\nThe design met all the intended objectives. The hardware for this lab, which was tested after making sure the software worked properly, worked on the first try. To encode a new song, I found the site music for music from Harry Potter, and transcribed the notes into frequencies using the table from the class website. A video of the final result, including Fur Elise and Hedwig’s Theme from Harry Potter, is shown below.\n\n\n\n\nI was successfully able to use my MCU to play music in this lab! The learning curve was steep, as this was my first time writing libraries in C and using a microcontroller in depth. However, I got really comfortable reading the datasheet and reference manual, and I gained a better understanding of the STM32 overall."
  },
  {
    "objectID": "uPs/lab4.html#lab-4-digital-audio",
    "href": "uPs/lab4.html#lab-4-digital-audio",
    "title": "Shreya Jampana's Portfolio",
    "section": "",
    "text": "In this lab, I learned how to use my MCU to play music by using timers. These timers generated square waves by toggling a GPIO pin at a specific frequency for specified durations. This lab also served as an introduction to working with the STM32 microcontroller boards. I gained a lot of experience with reading proper documentation (reference manual and datasheet) to understand clocks, timers, register, I/O, and more. The end result consisted of playing “Fur Elise” and my chosen song of “Hedwig’s Theme” from Harry Potter!\n\n\n\n\n\nI used the Timer 15 and Timer 16 registers in order to output a square wave signal from the microcontroller. For this lab, we had to read the datasheet carefully and write our own library in C from scratch. One of the reasons I chose Timers 15 and 16 is because they have the same register map. This meant I could take advantage of only having to write one struct in my timer header file. Another reason I chose these timers is that they both have the ability to be configured to a PWM mode and be connected to a GPIO pin in alternate function mode in order to have the desired functionality of producing a square wave output.\nAfter writing my header file, I wrote my timer source code, which consisted of four functions: initTIM to initialize my timer, delay_millis to provide a millisecond delay to set my note durations, initPWM to initialize the PWM mode of Timer 16, and setFreq to set the square wave to the desired frequency. Writing these four functions was the most difficult part of the lab, as they consisted of hours reading the reference manual to understand configuration, registers, and precisely which bits to set in which order to produce the desired functionality.\n\n\n\nTo go into more details on how the timers work, the timer configured in the PWM mode had the auto reload register (ARR) and the capture/compare register (CCR1) set in order to produce a specific period and duty cycle. The ARR value is set such that when the counter is equal to this value, it resets to 0, meaning this value sets the period of the signal. When the counter is less than the CCR1 value, it outputs a low (0), and when the counter is higher, it outputs a high (1), meaning the CCR1 value sets teh duty cycle. I set the CCR1 value to be half of the ARR value to have a duty cycle of 0.5. For the timer configured to set the delay, I utilized the ARR to control the delay, as it was set depending on the millisecond input.\nIn this lab, I used a phase-locked-loop (PLL) to set the microcontroller clock at 80 MHz, and to produce lower frequencies, I used prescalers. The timing calculations and theory behind my prescaler values are shown below in Figure 1.\n\n\n\nFigure 1. Timing calculations for frequency of sound output\n\n\nIn order to make sure that the minimum and maximum frequency and duration were supported with my chosen prescaler values, I did the calculations shown below in Figure 2.\n\n\n\nFigure 2. Max and min duration and frequency calculations\n\n\nOne of the specs for this lab was to produce individual pitches calculated to be accurate within 1% across the frequency range of 220-1000 Hz. Using the derived formula in figure 1 and careful unit conversion, I ran a timing analysis across this frequency range to make sure the spec was met. The calculations used to program the spreadsheet, showing examples of the pitches and durations being correct, as well as the resulting data is shown below in Figure 3 and 4, respectively.\n\n\n\nFigure 3. Calculations for spreadsheet and examples\n\n\n\n\n\nFigure 4. Pitch accuracy spreadsheet\n\n\n\n\n\nIn order to test the software’s functionality first, I uploaded the code to my MCU and used an oscilloscope to read the values of the GPIO pin to check that I was seeing the correct duty cycle and frequency. There was a lot of troubleshooting here, as I originlly did not see any square waves. I used Segger’s built in Debug mode to step through my code and ensure that all my registers were getting the value they were supposed to. After debugging and changing the way I configured/enabled things in my code, I started to see the correct frequency square waves in the oscilloscope.\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe circuit for this lab was simple. It contained an LM386 audio amplifier to drive the 8 ohm speaker and a potentiometer for volume control. The schematic is shown below in Figure 5.\n\n\n\nFigure 5. Schematic for audio amplifier circuit\n\n\n\n\n\n\nThe design met all the intended objectives. The hardware for this lab, which was tested after making sure the software worked properly, worked on the first try. To encode a new song, I found the site music for music from Harry Potter, and transcribed the notes into frequencies using the table from the class website. A video of the final result, including Fur Elise and Hedwig’s Theme from Harry Potter, is shown below.\n\n\n\n\nI was successfully able to use my MCU to play music in this lab! The learning curve was steep, as this was my first time writing libraries in C and using a microcontroller in depth. However, I got really comfortable reading the datasheet and reference manual, and I gained a better understanding of the STM32 overall."
  },
  {
    "objectID": "uPs/lab5.html",
    "href": "uPs/lab5.html",
    "title": "Shreya Jampana's Portfolio",
    "section": "",
    "text": "In this lab, we used our MCU to determine the speed of a motor by reading from a quadrature encoder. Lab 4 helped me get familiarized with the microcontroller and working with documentation, and this time, we tackled another aspect of microcontrollers: interrupts. Using these, I was able to process real-time, fast changes and record accurate measurements.\n\n\n\n\n\nAn encoder is a sensor that converts physical motion into electrical signals. A quadrature encoder is a common type of encoder that is used to measure the relative or absolute angle of a motor. They do this with the use of a patterned disk that is attached to the motor and spins with the motor. As shown in Figure 1 below, two stationary digital sensors 90 degrees out of phase are placed to produce two square waves that are 90 degrees out of phase with each other. The encoders used in this lab use magnets and hall effect sensors to produce the square waves. Using this theory and understanding, I designed my system to take full advantage of both signals to get the highest resolution measurement of the speed of the motor.\n\n\n\nFigure 1. Diagram of quadrature encoder [Avnet Silica]\n\n\n\n\n\nIn order to check the signals from the encoder and measure the speed of the motor, I used interrupts instead of polling. Polling involves continuously checking the status of the GPIO pins to detect whether or not the encoder output changed. This means the speed of taking a measurement is dependent on the time it takes all the commmands in the while loop to execute. This is problematic because if the code in the main loop is executing of a delay is being executed, you could miss the signal coming from the GPIO pin. This can cause timing issues and lead to inaccurate motor speeds being recorded due to sampling not happening fast/accurately enough. This problem can be overrided by using interrupts. Interrupts are event-driven instead of time-driven. This means that when the interrupt goes high, the CPU jumps to that address and the main/current execution context is paused as the interrupt is executed. After it’s done, it returns back to the main code and continues where it left off. By doing this, interrupts give immediate attention to signal changes and ensure that all measurements are registered and correspond exactly to encoder changes. Some math to back up this understanding is shown below in Figure 2.\n\n\n\nFigure 2. Interrupt vs. Polling Calculations\n\n\nIn order to achieve the highest resolution measurement, I used all edges of the encoder pulses. I did this by using two interrupts, one for Encoder A and one for Encoder B. Each encoder checked for the following four cases: clockwise rising edge, counter-clockwise rising edge, clockwise falling edge, and counter-clockwise falling edge. A counter was also used, which is explained more in the next section. The main steps of the program and the function calls are shown below in the flowchart in Figure 3.\n\n\n\nFigure 3. Lab 5 Program Flowchart\n\n\n\n\n\nThe interrupt design, described above, was the main portion of the software. Another important part was incorporating the counter into the interrupt and using that to calculate velocity. As mentioned above, each interrupt had four cases. In each case, if the motion was clockwise, the counter incremented. If the motion was counter-clockwise, the counter decreased. A graphical illustration of this using the signals from the encoder are shown below in Figure 4.\n\n\n\nFigure 4. Encoder signals edges for CW and CCW rotation\n\n\nThe following equation was used to determine the speed of the motor based on the counter: velocity = counter / (PPR * 4).\n\n\n\nIn order to make sure the measured speed matches the true motor speed and direction, I calculated the theoretical speed of the motor, hooked my motor up to the oscilloscope, and checked this against the values that my code output. From the datasheet, we know that at 12 V and 408 PPR, the speed of the motor should be 2.5 revolutions per second. Connecting the motor to the oscilloscope, I saw the following output, as shown in Figure 5.\n\n\n\nFigure 5. Motor encoder signals at 12 V\n\n\nAs shown on the oscilloscope screen, the output signal has a period of 848us. Calculations are shown below in Figure 6 to derive the speed of the motor using this value.\n\n\n\nFigure 6. Speed of motor from oscilloscope\n\n\nAt this same voltage, the following speed of motor was output from my code, with each measurement being taken one second apart.\n\n\n\nFigure 7. Speed of motor from code\n\n\nAll of these calculations are close to each other. The variation between the speed of the motor from the oscilloscope and that from the code is very small, and could be due to the motor speed itself fluctuating and not spinning at the same frequency. Also, signal capture on the oscilloscope can’t be verified, so it’s hard to determine if I’m capturing at the same rate on both the oscilloscope and on my console. Give this, I’m happy with the small variation and error rate between expected and measured.\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe circuit from this lab was very simple, as shown in the schematic below in Figure 8. It only consisted of connecting the motor encoder to the two MCU GPIO pins and a variable DC voltage +/- Vs being applied to the positive terminal of the motor from a power supply.\n\n\n\nFigure 8. Lab 5 Schematic\n\n\n\n\n\n\nThe design met all the intended objectives. After becoming comfortable with how to use the datasheet and reference manual for the MCU, this lab went by much smoother on the software end. The biggest point of confusion was understanding interrupts conceptually, but after that was done, the lab went by pretty smoothly. The final results are shown in the video below, with speed being output once per second on the console.\n\n\n\n\nI gained even more experience with my MCU in this lab. Learning more about interrupts also taught me how to properly read and process fast changes in order to make the most accurate measurements."
  },
  {
    "objectID": "uPs/lab5.html#lab-5-interrupts",
    "href": "uPs/lab5.html#lab-5-interrupts",
    "title": "Shreya Jampana's Portfolio",
    "section": "",
    "text": "In this lab, we used our MCU to determine the speed of a motor by reading from a quadrature encoder. Lab 4 helped me get familiarized with the microcontroller and working with documentation, and this time, we tackled another aspect of microcontrollers: interrupts. Using these, I was able to process real-time, fast changes and record accurate measurements.\n\n\n\n\n\nAn encoder is a sensor that converts physical motion into electrical signals. A quadrature encoder is a common type of encoder that is used to measure the relative or absolute angle of a motor. They do this with the use of a patterned disk that is attached to the motor and spins with the motor. As shown in Figure 1 below, two stationary digital sensors 90 degrees out of phase are placed to produce two square waves that are 90 degrees out of phase with each other. The encoders used in this lab use magnets and hall effect sensors to produce the square waves. Using this theory and understanding, I designed my system to take full advantage of both signals to get the highest resolution measurement of the speed of the motor.\n\n\n\nFigure 1. Diagram of quadrature encoder [Avnet Silica]\n\n\n\n\n\nIn order to check the signals from the encoder and measure the speed of the motor, I used interrupts instead of polling. Polling involves continuously checking the status of the GPIO pins to detect whether or not the encoder output changed. This means the speed of taking a measurement is dependent on the time it takes all the commmands in the while loop to execute. This is problematic because if the code in the main loop is executing of a delay is being executed, you could miss the signal coming from the GPIO pin. This can cause timing issues and lead to inaccurate motor speeds being recorded due to sampling not happening fast/accurately enough. This problem can be overrided by using interrupts. Interrupts are event-driven instead of time-driven. This means that when the interrupt goes high, the CPU jumps to that address and the main/current execution context is paused as the interrupt is executed. After it’s done, it returns back to the main code and continues where it left off. By doing this, interrupts give immediate attention to signal changes and ensure that all measurements are registered and correspond exactly to encoder changes. Some math to back up this understanding is shown below in Figure 2.\n\n\n\nFigure 2. Interrupt vs. Polling Calculations\n\n\nIn order to achieve the highest resolution measurement, I used all edges of the encoder pulses. I did this by using two interrupts, one for Encoder A and one for Encoder B. Each encoder checked for the following four cases: clockwise rising edge, counter-clockwise rising edge, clockwise falling edge, and counter-clockwise falling edge. A counter was also used, which is explained more in the next section. The main steps of the program and the function calls are shown below in the flowchart in Figure 3.\n\n\n\nFigure 3. Lab 5 Program Flowchart\n\n\n\n\n\nThe interrupt design, described above, was the main portion of the software. Another important part was incorporating the counter into the interrupt and using that to calculate velocity. As mentioned above, each interrupt had four cases. In each case, if the motion was clockwise, the counter incremented. If the motion was counter-clockwise, the counter decreased. A graphical illustration of this using the signals from the encoder are shown below in Figure 4.\n\n\n\nFigure 4. Encoder signals edges for CW and CCW rotation\n\n\nThe following equation was used to determine the speed of the motor based on the counter: velocity = counter / (PPR * 4).\n\n\n\nIn order to make sure the measured speed matches the true motor speed and direction, I calculated the theoretical speed of the motor, hooked my motor up to the oscilloscope, and checked this against the values that my code output. From the datasheet, we know that at 12 V and 408 PPR, the speed of the motor should be 2.5 revolutions per second. Connecting the motor to the oscilloscope, I saw the following output, as shown in Figure 5.\n\n\n\nFigure 5. Motor encoder signals at 12 V\n\n\nAs shown on the oscilloscope screen, the output signal has a period of 848us. Calculations are shown below in Figure 6 to derive the speed of the motor using this value.\n\n\n\nFigure 6. Speed of motor from oscilloscope\n\n\nAt this same voltage, the following speed of motor was output from my code, with each measurement being taken one second apart.\n\n\n\nFigure 7. Speed of motor from code\n\n\nAll of these calculations are close to each other. The variation between the speed of the motor from the oscilloscope and that from the code is very small, and could be due to the motor speed itself fluctuating and not spinning at the same frequency. Also, signal capture on the oscilloscope can’t be verified, so it’s hard to determine if I’m capturing at the same rate on both the oscilloscope and on my console. Give this, I’m happy with the small variation and error rate between expected and measured.\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe circuit from this lab was very simple, as shown in the schematic below in Figure 8. It only consisted of connecting the motor encoder to the two MCU GPIO pins and a variable DC voltage +/- Vs being applied to the positive terminal of the motor from a power supply.\n\n\n\nFigure 8. Lab 5 Schematic\n\n\n\n\n\n\nThe design met all the intended objectives. After becoming comfortable with how to use the datasheet and reference manual for the MCU, this lab went by much smoother on the software end. The biggest point of confusion was understanding interrupts conceptually, but after that was done, the lab went by pretty smoothly. The final results are shown in the video below, with speed being output once per second on the console.\n\n\n\n\nI gained even more experience with my MCU in this lab. Learning more about interrupts also taught me how to properly read and process fast changes in order to make the most accurate measurements."
  },
  {
    "objectID": "uPs/lab3.html",
    "href": "uPs/lab3.html",
    "title": "Shreya Jampana's Portfolio",
    "section": "",
    "text": "In this lab, we learned how to use the FPGA to scan inputs from a 4x4 keypad. The multiplexed display from lab 2 was combined with a keypad to display user inputs. A scanning system was designed to read the inputs from keypad scanner, and a method for switch debouncing was also implemented. This lab required carefuly, thought-outTsynchronous sequential design\n\n\n\nOne of the biggest design considerations was the scanner FSM. I went through many iterations, but in order to meet all of the specifications of the lab, ended up going with the following design:\n\n\n\nFigure 1. Scanner FSM\n\n\nAs shown in figure 1, the scanner FSM has one state for each column, and one for each row within each column. Given a row input, the FSM should transition from the column state to the state corresponding to the row input. If no rows are pressed, you transition to the next column and repeat the process. My FSM was originally simpler, but in order to account for edge cases in button pressing, I decided to make each row a distinct state.\nThe next big design consideration was debouncer FSM. One important consideration when working with the keypad matrix is switch bouncing. When a button is pressed, the input may take some time to settle. In order to not register the “bouncing” as multiple presses, a method for switch debouncing has to be implemented. I did this using another FSM, which interacts with my scanner FSM and the rest of my modules.\n\n\n\nFigure 2. Debouncer FSM\n\n\nAs shown in figure 2, the debouncer module has four states. The first state is idle, and as soon as a row press is detected, you transition to the second state, which is where debouncing happens. I implemented the debouncing using a counter. I chose an arbitrary debounce time of 50 ms, as I believed the key would stabilitize after that time. Since the debouncer operates on the slow clock (at 183 Hz), I determined the number of cycles the counter needed to iterate by multiplying the clock frequency by the debouncing time, which gave me a number of ~10. Therefore, as soon as the counter reaches 10, you transition to the next stage, in which a pulse is sent out. You turn the pulse off in the final stage, and go back to the idle state. This pulse allows for regulation of decoding, maintaining it to only happen after the debouncing is complete.\nAfter designing the FSMs and all the interacting modules (explained in block diagram section below), I wired up the keypad. Seeing as our design was active high, I used pull down resistors for the rows. The picture of the wired circuit is shown below in figure 3.\n\n\n\nFigure 3. Physical Circuit and Setup\n\n\nIn order to test the system, I wrote some test benches for the more crucial modules and tested the keypad physically for all edge cases.\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe block diagram for my system is shown below in figure 4.\n\n\n\nFigure 4. System block diagram\n\n\nThe high speed oscillator lives in the top level module, and a slowClock module after it divides the high speed 48MHz clock into a slower 183Hz clock, which is used by the rest of the system. Following this, a scanner module takes in the row input and powers the column. It also sends out the 8-bit keyValue, which contains information about the row and column pressed. This module also outputs whether or not a row is pressed, which is used by the debouncer to debounce the press. The debouncer module outputs a pulse once debouncing is complete. Once the segDriver module receives a pulse, it takes the keyValue and decodes it into a four bit input. This module also shifts the old digit to the left, and puts the new digit on the right. These are sent to the switcher, which sends power to the seven segment (using enables) at the same frequency. The seven segment module then dipays the numbers.\n\n\n\nThe schematic for the system is shown below in figure 5. It includes the FPGA, the dual seven segment, and the keypad.\n\n\n\nFigure 5. System Schematic\n\n\n\n\n\n\nThe design meets all of the proficiency specs. It registers key presses, and moves old key presses to the left and puts new key presses on the right. All the LEDs are equally bright. The design also doesn’t lock up when multiple keys are pressed.\nThroughout the lab, there were multiple bugs I resolved. I spent a long time finalizing the design of the FSMs and figuring out how to implement the debouncing logic. After quickly writing up the System Verilog, I uploaded my code and noticed that there were two 0s being displayed but no presses were being registered. This was the biggest bug, and was solved with a lot of simulation, checking the code to decode keyValue, and dealing with clock issues.\nI originally had a smaller FSM, but changed it to account for every row case so that when one key is pressed, and a second is also pressed in the same column at the same time, when you let go of the original key, the second key registers. I still have some issues that I am debugging. For example, for the two rightmost columns, when I press one key and press another, it registers the press even though the other is held down. This only happens for the two rightmost columns. I also was not able to implement a synchronizer successfully.\n\n\n\nDespite the small issues discussed above, my FPGA design was successfully able to scan inputs from a 4x4 keypad and debounce all the keys."
  },
  {
    "objectID": "uPs/lab3.html#lab-3-keypad-scanner",
    "href": "uPs/lab3.html#lab-3-keypad-scanner",
    "title": "Shreya Jampana's Portfolio",
    "section": "",
    "text": "In this lab, we learned how to use the FPGA to scan inputs from a 4x4 keypad. The multiplexed display from lab 2 was combined with a keypad to display user inputs. A scanning system was designed to read the inputs from keypad scanner, and a method for switch debouncing was also implemented. This lab required carefuly, thought-outTsynchronous sequential design\n\n\n\nOne of the biggest design considerations was the scanner FSM. I went through many iterations, but in order to meet all of the specifications of the lab, ended up going with the following design:\n\n\n\nFigure 1. Scanner FSM\n\n\nAs shown in figure 1, the scanner FSM has one state for each column, and one for each row within each column. Given a row input, the FSM should transition from the column state to the state corresponding to the row input. If no rows are pressed, you transition to the next column and repeat the process. My FSM was originally simpler, but in order to account for edge cases in button pressing, I decided to make each row a distinct state.\nThe next big design consideration was debouncer FSM. One important consideration when working with the keypad matrix is switch bouncing. When a button is pressed, the input may take some time to settle. In order to not register the “bouncing” as multiple presses, a method for switch debouncing has to be implemented. I did this using another FSM, which interacts with my scanner FSM and the rest of my modules.\n\n\n\nFigure 2. Debouncer FSM\n\n\nAs shown in figure 2, the debouncer module has four states. The first state is idle, and as soon as a row press is detected, you transition to the second state, which is where debouncing happens. I implemented the debouncing using a counter. I chose an arbitrary debounce time of 50 ms, as I believed the key would stabilitize after that time. Since the debouncer operates on the slow clock (at 183 Hz), I determined the number of cycles the counter needed to iterate by multiplying the clock frequency by the debouncing time, which gave me a number of ~10. Therefore, as soon as the counter reaches 10, you transition to the next stage, in which a pulse is sent out. You turn the pulse off in the final stage, and go back to the idle state. This pulse allows for regulation of decoding, maintaining it to only happen after the debouncing is complete.\nAfter designing the FSMs and all the interacting modules (explained in block diagram section below), I wired up the keypad. Seeing as our design was active high, I used pull down resistors for the rows. The picture of the wired circuit is shown below in figure 3.\n\n\n\nFigure 3. Physical Circuit and Setup\n\n\nIn order to test the system, I wrote some test benches for the more crucial modules and tested the keypad physically for all edge cases.\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe block diagram for my system is shown below in figure 4.\n\n\n\nFigure 4. System block diagram\n\n\nThe high speed oscillator lives in the top level module, and a slowClock module after it divides the high speed 48MHz clock into a slower 183Hz clock, which is used by the rest of the system. Following this, a scanner module takes in the row input and powers the column. It also sends out the 8-bit keyValue, which contains information about the row and column pressed. This module also outputs whether or not a row is pressed, which is used by the debouncer to debounce the press. The debouncer module outputs a pulse once debouncing is complete. Once the segDriver module receives a pulse, it takes the keyValue and decodes it into a four bit input. This module also shifts the old digit to the left, and puts the new digit on the right. These are sent to the switcher, which sends power to the seven segment (using enables) at the same frequency. The seven segment module then dipays the numbers.\n\n\n\nThe schematic for the system is shown below in figure 5. It includes the FPGA, the dual seven segment, and the keypad.\n\n\n\nFigure 5. System Schematic\n\n\n\n\n\n\nThe design meets all of the proficiency specs. It registers key presses, and moves old key presses to the left and puts new key presses on the right. All the LEDs are equally bright. The design also doesn’t lock up when multiple keys are pressed.\nThroughout the lab, there were multiple bugs I resolved. I spent a long time finalizing the design of the FSMs and figuring out how to implement the debouncing logic. After quickly writing up the System Verilog, I uploaded my code and noticed that there were two 0s being displayed but no presses were being registered. This was the biggest bug, and was solved with a lot of simulation, checking the code to decode keyValue, and dealing with clock issues.\nI originally had a smaller FSM, but changed it to account for every row case so that when one key is pressed, and a second is also pressed in the same column at the same time, when you let go of the original key, the second key registers. I still have some issues that I am debugging. For example, for the two rightmost columns, when I press one key and press another, it registers the press even though the other is held down. This only happens for the two rightmost columns. I also was not able to implement a synchronizer successfully.\n\n\n\nDespite the small issues discussed above, my FPGA design was successfully able to scan inputs from a 4x4 keypad and debounce all the keys."
  },
  {
    "objectID": "uPs/lab1.html",
    "href": "uPs/lab1.html",
    "title": "Shreya Jampana's Portfolio",
    "section": "",
    "text": "In this lab, we soldered our E155 protoboard and implemented designs on the FPGA to drive on-board LEDs and a seven segment display. Two of the LEDs outputted combinational logic, and one of them was blinked at a specific frequency using the on-board high-speed oscillator.\n\n\n\nAfter soldering and testing the FPGA, MCU, and the development board for proper functionality, I designed my FPGA to further test the hardware on my board and operate a 7-segment display. The design consisted of the following:\n\n\n\n\n\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\nclk\ninput\n48 MHz clock on FPGA\n\n\ns[3:0]\ninput\nfour DIP switches (on the board)\n\n\nled[2:0]\noutput\n3 on-board LEDs\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThere were two primary aspects to this lab: operate three on-board LEDs (led[0], led[1], and led[2]) and create a 7-segment display.\nThe relationship between the switches (s0, s1, s2, s3) and the first two LEDs (led[0] and led[1]) were provided in the form of truth tables. Upon deriving the combinational logic, it was clear that led[0] was an exclusive or (XOR) of s0 and s1, while led[1] was an AND of s2 and s3. The third LED, led[3], was to be blinked at 2.4Hz. This was done using the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library. This oscillator generated a 48 MHz clock, and a counter was used to divide this down so the blinking frequency could be visualized on led[2]. In order to generate a 2.4 Hz signal that would complete a half cycle, a clock divider module was designed to count every (0.5)* 48 MHz/2.4 Hz, or 10 million ticks.\nThe 7-segment display was designed to display a signle hexadecimal digit specified by a four bit binary input s[3:0]. To do this, a separate SystemVerliog module was written, which contained 16 case statements detailing which segments of the display should be lit to create the hexademical digit corresponding to the dip switch input of s[3:0]. When breadboarding this design, it was important to remember that in the common annode display we were working with, a logic 0 applied to the cathode turned on the segment.\nAfter designing the modules on SystemVerilog and programming the designs to the FPGA, we tested our design. For the LEDs, in order to test led[0] and led[1], we tried the different combination logic using the switches to ensure the proper XOR and AND gate functionality. For led[2], we used an oscilloscope to verify the blink frequency of 2.4 Hz. To test the 7-segment display, we operated the DIP switches to ensure that the four bit binary numbers displayed their corresponding hexadecimal digit with equal brightness in segments, as shown in Figure 1.\n\n\n\nFigure 1. Output of hex digit 5 for a binary input of 4’b0101\n\n\nIn order to enxure that the current draw for each segment in the 7-segment display was within recommended operating conditions, the calculations shown in Figure 2 were done. The absolute maximum current rating is 20 mA, and as the calculations show, we have a 1.3 mA current draw, which is standard for LEDs.\n\n\n\nFigure 2. Calculations for current draw in 7-segment display\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 3. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 3 demonstrates the overall architecture of the design. The top-level module (top) includes two submodules: the high-speed oscillator block (HSOSC) and the module to operate the 7-segment display. The operation of the LEDs happens in the top-level module as combinational logic.\n\n\n\n\n\n\nFigure 4. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 4. The left side of the UPduino shows the inputs, while the right side shows the outputs. The inputs consist of a reset button and four switches. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin was not floating. The outputs consist of the seven LEDs from the 7-segment display, and three LEDs to test the combinational logic and blinking. These LEDs are connected using a 1kΩ current-limiting resistor to ensure the output current did not exceed the maximum output current of the FPGA I/O pins.\n\n\n\n\n\n\nTwo testbenches were written in SystemVerilog, one for the top-level and one for the 7-segment display modules, in order to verify that the designs were working as intended. Using the written test vectors, the testbenches ran all 16 cominations of the DIP switches in order to simulate and test if the led[2:0] and seg[6:0] outputs matched the expected outputs.\nAs shown in the simulation images shown in Figures 5 and 6, all the simulations passed and produced the expected outputs. Therefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in just a few seconds, and the hardware displayed all the required lights brightly.\n\n\n\nFigure 5. Top-level module QuestaSim simulation\n\n\n\n\n\nFigure 6. 7-segment module QuestaSim simulation\n\n\n\n\n\n\nMy FPGA designs successfully controlled a 7-segment display and LEDs, thus validating the functionality of my soldered protoboard. By blinking one of the LEDs at 2.4 Hz, I also validated the functionality of the on-board high-speed oscillator."
  },
  {
    "objectID": "uPs/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "uPs/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "Shreya Jampana's Portfolio",
    "section": "",
    "text": "In this lab, we soldered our E155 protoboard and implemented designs on the FPGA to drive on-board LEDs and a seven segment display. Two of the LEDs outputted combinational logic, and one of them was blinked at a specific frequency using the on-board high-speed oscillator.\n\n\n\nAfter soldering and testing the FPGA, MCU, and the development board for proper functionality, I designed my FPGA to further test the hardware on my board and operate a 7-segment display. The design consisted of the following:\n\n\n\n\n\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\nclk\ninput\n48 MHz clock on FPGA\n\n\ns[3:0]\ninput\nfour DIP switches (on the board)\n\n\nled[2:0]\noutput\n3 on-board LEDs\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThere were two primary aspects to this lab: operate three on-board LEDs (led[0], led[1], and led[2]) and create a 7-segment display.\nThe relationship between the switches (s0, s1, s2, s3) and the first two LEDs (led[0] and led[1]) were provided in the form of truth tables. Upon deriving the combinational logic, it was clear that led[0] was an exclusive or (XOR) of s0 and s1, while led[1] was an AND of s2 and s3. The third LED, led[3], was to be blinked at 2.4Hz. This was done using the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library. This oscillator generated a 48 MHz clock, and a counter was used to divide this down so the blinking frequency could be visualized on led[2]. In order to generate a 2.4 Hz signal that would complete a half cycle, a clock divider module was designed to count every (0.5)* 48 MHz/2.4 Hz, or 10 million ticks.\nThe 7-segment display was designed to display a signle hexadecimal digit specified by a four bit binary input s[3:0]. To do this, a separate SystemVerliog module was written, which contained 16 case statements detailing which segments of the display should be lit to create the hexademical digit corresponding to the dip switch input of s[3:0]. When breadboarding this design, it was important to remember that in the common annode display we were working with, a logic 0 applied to the cathode turned on the segment.\nAfter designing the modules on SystemVerilog and programming the designs to the FPGA, we tested our design. For the LEDs, in order to test led[0] and led[1], we tried the different combination logic using the switches to ensure the proper XOR and AND gate functionality. For led[2], we used an oscilloscope to verify the blink frequency of 2.4 Hz. To test the 7-segment display, we operated the DIP switches to ensure that the four bit binary numbers displayed their corresponding hexadecimal digit with equal brightness in segments, as shown in Figure 1.\n\n\n\nFigure 1. Output of hex digit 5 for a binary input of 4’b0101\n\n\nIn order to enxure that the current draw for each segment in the 7-segment display was within recommended operating conditions, the calculations shown in Figure 2 were done. The absolute maximum current rating is 20 mA, and as the calculations show, we have a 1.3 mA current draw, which is standard for LEDs.\n\n\n\nFigure 2. Calculations for current draw in 7-segment display\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 3. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 3 demonstrates the overall architecture of the design. The top-level module (top) includes two submodules: the high-speed oscillator block (HSOSC) and the module to operate the 7-segment display. The operation of the LEDs happens in the top-level module as combinational logic.\n\n\n\n\n\n\nFigure 4. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 4. The left side of the UPduino shows the inputs, while the right side shows the outputs. The inputs consist of a reset button and four switches. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin was not floating. The outputs consist of the seven LEDs from the 7-segment display, and three LEDs to test the combinational logic and blinking. These LEDs are connected using a 1kΩ current-limiting resistor to ensure the output current did not exceed the maximum output current of the FPGA I/O pins.\n\n\n\n\n\n\nTwo testbenches were written in SystemVerilog, one for the top-level and one for the 7-segment display modules, in order to verify that the designs were working as intended. Using the written test vectors, the testbenches ran all 16 cominations of the DIP switches in order to simulate and test if the led[2:0] and seg[6:0] outputs matched the expected outputs.\nAs shown in the simulation images shown in Figures 5 and 6, all the simulations passed and produced the expected outputs. Therefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in just a few seconds, and the hardware displayed all the required lights brightly.\n\n\n\nFigure 5. Top-level module QuestaSim simulation\n\n\n\n\n\nFigure 6. 7-segment module QuestaSim simulation\n\n\n\n\n\n\nMy FPGA designs successfully controlled a 7-segment display and LEDs, thus validating the functionality of my soldered protoboard. By blinking one of the LEDs at 2.4 Hz, I also validated the functionality of the on-board high-speed oscillator."
  },
  {
    "objectID": "uPs/lab2.html",
    "href": "uPs/lab2.html",
    "title": "Shreya Jampana's Portfolio",
    "section": "",
    "text": "In this lab, time multiplexing was used to efficiently drive two seven-segment displays with a single set of FPGA I/O pins. The sum of both numbers were displayed on five separate LEDs. Additionally, transistors were used to drive large currents from the FPGA pins.\n\n\n\nThe design of the time multiplexing scheme was one of the main components of this lab. Time multiplexing is a technique that is used to share a common expensive hardware resource for several purposes at different times. In this lab, time multiplexing was used to drive a single seven-segment decoder module to run both halves of a dual display.\nIn terms of wiring, this is done by connecting a single GPIO pin on the FPGA to the same segment (e.g. segment e) on both the seven-segment displays. However, in order to control which half of the dual display is active, the common anode of only one display at a time is turned ON. The power to these two displays are controlled by two separate GPIO pins, which are toggled at a certain speed in order for two distinct numbers to appear simultaneously on each display. Due to the anode requiring more current than the FPGA output pin can drive, a 2N3906 PNP transistor was used to limit the base current and not draw too much from the FPGA pin. Both of the dual displays are controlled by four bit DIP switches, and the sum of both numbers is displayed as a five bit number on five separate LEDs. The hardware layout, with the breadboard and wiring as described above, is shown in Figure 1.\n\n\n\nFigure 1. Wiring of the dual seven-segment display, LEDs, and transistor circuits\n\n\nThe wiring and breadboard layout was intuitively done to enable easy debugging and be visually appealing. In order to justify resistor choices, calcuations were done, as shown in Figure 2, to ensure proper brightness of the five individual LEDs and that the current draw/sink on all the FPGA pins was below the currents specified in the recommended operating conditions.\n\n\n\nFigure 2. Calculations to justify chosen resistor values for the dual seven-segment display, the five individual LEDs, and the PNP transistor\n\n\nFrom a software standpoint, important decisions were made in order to split up the required tasks of the lab into respective modules. A top level module was used to instantiate the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library, which was the 48 MHz clock that was divided and used throughout the system. The top level module also contained the combinational logic for the five individual LEDs, as they were simple and therefore did not require a separate module.\nOne of the most important design considerations was the speed at which the two displays were toggled. This was done using a clock divider and 32-bit counter, where choosing different bits of the counter in the clock division allowed for different switching speeds. After testing, it was determined that the 18th bit of the counter produced a toggling speed that ensured that both hexadecimal digits lit up simultaneously without visible oscillation and without the digits bleeding into each other. At this speed, the clock divider enabled power to each of the displays in the dual display and the four bit inputs were sent one at a time to the seven segment module.\nIn order to verify the software, three testbenches were written with one for each module——top level, seven-segment, and multiplexer. The seven-segment testbench checked that the correct segments displayed with the corresponding four bit inpupts. The top level testbench checked that the combinational logic for the five LEDs functioned as properly. The multiplexer module checked that the input to the seven segment display was the correct four bit input corresponding to which display was enabled. The testbenches also checked the toggling of the enable signals. The waveforms are shown in the Results and Discussion section. In order to test the hardware, all switches and their summing combinational logic was tested on the breadboard. A picture from one of these tests is shown below in Figure 3.\n\n\n\nFigure 3. Image from testing displaying functioning hardware. The hex digit “b” is displayed on the left, and “0” is displayed on the right, with their sum equalling 11 and being displayed on the five individual LEDs.\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 4. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 4 demonstrates the overall architecture of the design. The top-level module includes three submodules: the high-speed oscillator block (HSOSC), the seven-segment module to operate the 7-segment display, and the multiplexer module to operate the correct switching/toggling of the dual displays.\n\n\n\n\n\n\nFigure 5. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 5. The left side of the UPduino shows the inputs, which are the reset and two sets of four-input DIP switches with an internal 100 kΩ pullup resistor to ensure the active low reset pin was not floating. The right side shows the outputs, which are the GPIO pins connecting the transistors to power, the two enables, the seven segments, and the five LEDs. All of the LEDs and transistors are connected to current-limiting resistors, the calculations for which are shown above in Figure 2.\n\n\n\n\n\n\nThree testbenches were written in SystemVerilog, one for each of the modules (top level, multiplexer, and seven-segment), in order to show that the combinational logic works and that the enables toggle and produce the correct, corresponding display.\nAs shown in the simulation images below, all the simulations passed and produced the expected outputs. Figures 6 and 7 show the simulation waveforms for the top level module. Figure 6 shows that the led variable is the correct sum of the 8-bit counter input. Figure 7 shows that when zoomed out, the enable toggles and tests the other cases. Figure 8 shows that s (input to the seven-segment module) gets the correct four bit input during the correct enable. In the waveforms, it is visible that the value of four bits of s_counter (the input) match the value of s one clock cycle later. This makes sense because s is an output of the multiplexer module, and thus displays its value one clock cycle later. Similar to the top level, zooming out shows that the enable switches as expected to test all the other cases. Figure 10 shows the seven-segment waveforms also producing the expected outputs for the segment values on the display.\n\n\n\nFigure 6. Top-level module QuestaSim simulation showing correct combinational logic\n\n\n\n\n\nFigure 7. Zoomed-out view of top-level module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 8. Multiplexer module QuestaSim simulation showing the seven-segment getting the correct input\n\n\n\n\n\nFigure 9. Zoomed-out view of multiplexer module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 10. Seven-segment module QuestaSim simulation\n\n\nTherefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in a few seconds, and the hardware displayed all the required LEDs brightly.\n\n\n\n\nMy FPGA designs successfully controlled a time multiplexing scheme to drive two 7-segment displays with a single set of FPGA I/O pins. A transistor to drive large currents from the FPGA pins was also successfully implemented. Additionally, I gained a lot of experience with building testbenches and modular Verilog systems."
  },
  {
    "objectID": "uPs/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "uPs/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "Shreya Jampana's Portfolio",
    "section": "",
    "text": "In this lab, time multiplexing was used to efficiently drive two seven-segment displays with a single set of FPGA I/O pins. The sum of both numbers were displayed on five separate LEDs. Additionally, transistors were used to drive large currents from the FPGA pins.\n\n\n\nThe design of the time multiplexing scheme was one of the main components of this lab. Time multiplexing is a technique that is used to share a common expensive hardware resource for several purposes at different times. In this lab, time multiplexing was used to drive a single seven-segment decoder module to run both halves of a dual display.\nIn terms of wiring, this is done by connecting a single GPIO pin on the FPGA to the same segment (e.g. segment e) on both the seven-segment displays. However, in order to control which half of the dual display is active, the common anode of only one display at a time is turned ON. The power to these two displays are controlled by two separate GPIO pins, which are toggled at a certain speed in order for two distinct numbers to appear simultaneously on each display. Due to the anode requiring more current than the FPGA output pin can drive, a 2N3906 PNP transistor was used to limit the base current and not draw too much from the FPGA pin. Both of the dual displays are controlled by four bit DIP switches, and the sum of both numbers is displayed as a five bit number on five separate LEDs. The hardware layout, with the breadboard and wiring as described above, is shown in Figure 1.\n\n\n\nFigure 1. Wiring of the dual seven-segment display, LEDs, and transistor circuits\n\n\nThe wiring and breadboard layout was intuitively done to enable easy debugging and be visually appealing. In order to justify resistor choices, calcuations were done, as shown in Figure 2, to ensure proper brightness of the five individual LEDs and that the current draw/sink on all the FPGA pins was below the currents specified in the recommended operating conditions.\n\n\n\nFigure 2. Calculations to justify chosen resistor values for the dual seven-segment display, the five individual LEDs, and the PNP transistor\n\n\nFrom a software standpoint, important decisions were made in order to split up the required tasks of the lab into respective modules. A top level module was used to instantiate the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library, which was the 48 MHz clock that was divided and used throughout the system. The top level module also contained the combinational logic for the five individual LEDs, as they were simple and therefore did not require a separate module.\nOne of the most important design considerations was the speed at which the two displays were toggled. This was done using a clock divider and 32-bit counter, where choosing different bits of the counter in the clock division allowed for different switching speeds. After testing, it was determined that the 18th bit of the counter produced a toggling speed that ensured that both hexadecimal digits lit up simultaneously without visible oscillation and without the digits bleeding into each other. At this speed, the clock divider enabled power to each of the displays in the dual display and the four bit inputs were sent one at a time to the seven segment module.\nIn order to verify the software, three testbenches were written with one for each module——top level, seven-segment, and multiplexer. The seven-segment testbench checked that the correct segments displayed with the corresponding four bit inpupts. The top level testbench checked that the combinational logic for the five LEDs functioned as properly. The multiplexer module checked that the input to the seven segment display was the correct four bit input corresponding to which display was enabled. The testbenches also checked the toggling of the enable signals. The waveforms are shown in the Results and Discussion section. In order to test the hardware, all switches and their summing combinational logic was tested on the breadboard. A picture from one of these tests is shown below in Figure 3.\n\n\n\nFigure 3. Image from testing displaying functioning hardware. The hex digit “b” is displayed on the left, and “0” is displayed on the right, with their sum equalling 11 and being displayed on the five individual LEDs.\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 4. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 4 demonstrates the overall architecture of the design. The top-level module includes three submodules: the high-speed oscillator block (HSOSC), the seven-segment module to operate the 7-segment display, and the multiplexer module to operate the correct switching/toggling of the dual displays.\n\n\n\n\n\n\nFigure 5. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 5. The left side of the UPduino shows the inputs, which are the reset and two sets of four-input DIP switches with an internal 100 kΩ pullup resistor to ensure the active low reset pin was not floating. The right side shows the outputs, which are the GPIO pins connecting the transistors to power, the two enables, the seven segments, and the five LEDs. All of the LEDs and transistors are connected to current-limiting resistors, the calculations for which are shown above in Figure 2.\n\n\n\n\n\n\nThree testbenches were written in SystemVerilog, one for each of the modules (top level, multiplexer, and seven-segment), in order to show that the combinational logic works and that the enables toggle and produce the correct, corresponding display.\nAs shown in the simulation images below, all the simulations passed and produced the expected outputs. Figures 6 and 7 show the simulation waveforms for the top level module. Figure 6 shows that the led variable is the correct sum of the 8-bit counter input. Figure 7 shows that when zoomed out, the enable toggles and tests the other cases. Figure 8 shows that s (input to the seven-segment module) gets the correct four bit input during the correct enable. In the waveforms, it is visible that the value of four bits of s_counter (the input) match the value of s one clock cycle later. This makes sense because s is an output of the multiplexer module, and thus displays its value one clock cycle later. Similar to the top level, zooming out shows that the enable switches as expected to test all the other cases. Figure 10 shows the seven-segment waveforms also producing the expected outputs for the segment values on the display.\n\n\n\nFigure 6. Top-level module QuestaSim simulation showing correct combinational logic\n\n\n\n\n\nFigure 7. Zoomed-out view of top-level module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 8. Multiplexer module QuestaSim simulation showing the seven-segment getting the correct input\n\n\n\n\n\nFigure 9. Zoomed-out view of multiplexer module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 10. Seven-segment module QuestaSim simulation\n\n\nTherefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in a few seconds, and the hardware displayed all the required LEDs brightly.\n\n\n\n\nMy FPGA designs successfully controlled a time multiplexing scheme to drive two 7-segment displays with a single set of FPGA I/O pins. A transistor to drive large currents from the FPGA pins was also successfully implemented. Additionally, I gained a lot of experience with building testbenches and modular Verilog systems."
  },
  {
    "objectID": "uPs/index.html",
    "href": "uPs/index.html",
    "title": "Microprocessor-based Systems Projects",
    "section": "",
    "text": "Lab 1: FPGA & MCU Testing and Setup\n\n\nLab 2: Multiplexed 7-Segment Display\n\n\nLab 3: Keypad Scanner\n\n\nLab 4: Digital Audio\n\n\nLab 5: Interrupts"
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Projects at HMC",
    "section": "",
    "text": "Projects in Microprocessor-based Systems\nI am currently taking the class ENGR155: Microprocessor-based Systems: Design & Applications. This course is entirely project-based, so follow along here as I gain experience with digital design, FPGAs, microcontrollers, and embedded programming!\n\n\nRF Receiver and Communication System\n\n\n\n\n\n\n\n\nIn ENGR157: Radio Frequency Circuit Design, I designed and built a receiver capable of decoding a secret message being sent from a transmitter in our RF lab. My receiver using a direct down-conversion architecture, and I built it using Mini Circuits modules. I used a receive antenna, whose S11 and radiation pattern I gathered, along with amplifiers, a mixer, and a low-pass filter around a 2.25 GHz local oscillator to realize the full RF chain.\nI performed careful analysis of the receiver’s expected and experimental performance by creating a link budget spreadsheet, which shows the expected and measured signal power, noise temperature and power of distortion products at each stage. I captured spectra at each stage of the receiver chain to confirm proper operation, identified and filtered out blocker and WiFi signals, and decoded the transmitted binary stream into the ASCII message “HMC.” In addition, I characterized the receiver’s nonlinearity by measuring its input intercept point (IIP3) and comparing it with analytical predictions, highlighting the impact of distortion products on real-world performance. Although analytical models predicted a much longer range, the receiver reliably detected the signal up to ~80 meters before hitting the noise floor.\nThis project strengthened my expertise in RF system integration, link budget analysis, spectrum analysis, nonlinear characterization, and practical measurement techniques. It provided experience in bridging theoretical predictions with real-world behavior, validating each stage of an RF system, and overcoming challenges in experimental testing. Check out my final report here to learn more about this project in detail!\n\n\nRF Ladder Filter Design\n\n\n\n\n\n\n\n\nIn ENGR157: Radio Frequency Circuit Design, I designed, simulated, and tested a 5th-order Butterworth low-pass filter to meet specific requirements: a 100 MHz passband edge, at least 20 dB rejection by 200 MHz, less than 1 dB of in-band ripple, and under 3 dB insertion loss. Starting with analytical calculations from filter design tables, I derived component values and verified the design through LTSpice simulations.\nI then adapted the design for implementation on a PCB, accounting for board parasitics and practical component availability. By scaling capacitor and inductor values, I was able to counteract parasitic effects that shifted the frequency response, ensuring the measured filter response aligned with theoretical predictions. In the end, my design met all of the required specifications.\nThis project strengthened my understanding of RF filter design, parasitic effects, and the importance of matching analytical, simulated, and measured results. It also gave me hands-on experience in PCB-based RF implementation, troubleshooting discrepancies between ideal and real systems, and validating performance with network analyzer measurements. See my final report here to learn more details about my design and implementation!\n\n\nAutonomous Underwater Robot\n\n\n\n\n\n\n\n\n\n\n\nIn ENGR80: Experimental Engineering, I worked on a team to design and build an autonomous underwater vehicle (AUV) capable of measuring current velocity at different depths. Our AUV integrated a Teensy microcontroller, IMU, GPS, pressure sensor, thermocouple, and flex sensor in a waterproof housing, with a proportional control algorithm enabling autonomous dives, data collection, and resurfacing.\nWe calibrated and validated the flex sensor using the Harvey Mudd wind tunnel and a gantry crane in a freshwater tank, applying similitude principles to model ocean currents. COMSOL simulations of hydrodynamic drag complemented these experiments, helping refine our design. Field tests at Phake Lake and Dana Point Harbor confirmed reliable depth tracking with the pressure sensor and meaningful velocity measurements across different current conditions.\nThis project strengthened my skills in embedded systems, sensor design and calibration, and control algorithms, while giving me hands-on experience with COMSOL modeling, experimental testing, and applying fluid dynamics principles to real-world prototypes. I also gained a lot of team-working skills, as this project was most definitely a team effort! Learn more technical details about our project here in our final report.\n\n\nZipline Speed Control System Design\n\n\n\n\n\n\n\n\nIn ENGR72: Applied Mathematics for Engineers, I worked on a design project to model and optimize an active speed control system for a zipline. The goal was to ensure that riders of different masses completed the ride safely without exceeding an exit velocity of 5 m/s, while maximizing the ride experience for the average rider.\nI modeled the catenary shape of the cable and applied the governing equations of motion for riders of different masses. Using MATLAB, I developed simulations of velocity profiles and implemented the constraints with a nonlinear optimization solver, optimizing variables such as cable tension and vertical drop while ensuring safe exit speeds and acceptable rope tension. My final solution ensured that all design constraints were met. The model also highlighted tradeoffs between maximizing performance for the average rider and maintaining safety across a wide range of conditions.\nThis project strengthened my skills in formulating physics-based optimization problems, implementing nonlinear constraints in MATLAB, and balancing safety, performance, and design feasibility through computational modeling. Check out my report here, as I work through the steps of designing the zipline and implementing the optimization.\n\n\nPI and State Feedback Digital Controller for Analog Circuit\n\nIn ENGR102: Advanced Systems Engineering II, I worked on a project to design and implement a digital controller for an overdamped RC circuit. The objective was to meet performance specifications such as minimizing overshoot, ensuring zero steady-state error, and achieving a fast settling time, all under real-world constraints like limited input voltage and discrete sampling.\nI began by modeling the system in MATLAB and Simulink, then designed and tested a PI compensator in both continuous and discrete time. After validating the design through simulations, I implemented the controller on an Arduino Uno to regulate the physical RC circuit. To further improve performance, I also designed an observer-based state feedback controller, tuning it in MATLAB and confirming its effectiveness through both simulation and hardware testing.\nThis project strengthened my skills in digital control design, MATLAB/Simulink modeling, and embedded system implementation, while giving me hands-on experience bridging theoretical design methods with experimental hardware results. Find all the steps that I took to implement this controller in here in my report!\n\n\nInverted Pendulum State Space Control\n\n\n\n\n\n\n\n\nIn ENGR102: Advanced Systems Engineering II, I worked on the classic problem of stabilizing an inverted pendulum on a moving cart, an inherently unstable system. The objective was to design a controller that moved the cart to a target position within 10 seconds without overshoot, while keeping the pendulum upright under disturbances.\nI modeled the system in MATLAB and Simulink using a state-space representation, then designed a state feedback controller with integral action and an observer to estimate unmeasured states. By tuning controller and observer poles, I achieved stable performance in simulation, with the cart reaching its target smoothly and the pendulum maintaining near-upright stability.\nThis project strengthened my skills in state-space control, observer design, and MATLAB/Simulink modeling, while giving me experience with stabilizing unstable systems and balancing robustness with performance. Check out my final report here for more details!\n\n\nDigital and Analog Filter Design\n\nIn ENGR101: Advanced Systems Engineering I, my team designed and tested both analog and digital filters to generate a clean sinusoidal signal from a pulse train input. We built a fourth-order Butterworth low-pass filter using a two-stage Sallen-Key op-amp circuit and implemented a modified comb filter digitally on an Arduino microcontroller.\nWe analyzed the system using Fourier series methods and frequency response functions, then validated our design experimentally with FFTs of the input and output signals. To improve accuracy, we applied windowing techniques such as the Hanning window and compared measured versus theoretical results, identifying key sources of error such as component tolerances, sampling limitations, and noise.\nThis project strengthened my skills in analog and digital filter design, hands-on circuit implementation, signal processing with MATLAB, and embedded programming on Arduino, while also teaching me how to troubleshoot discrepancies between theory and experimental results. Find our final report here for more details!\n\n\nAuditory Cueing System\n\n\n\n\n\n\n\n\nIn ENGR164: Introduction to Biomedical Engineering, I worked on a team project to design a wearable auditory cueing system aimed at improving Freezing of Gait (FoG) in patients with Parkinson’s disease. Our solution was a compact, metronome-based device that delivered rhythmic auditory cues to help synchronize stepping and initiate movement.\nI designed and tested the electronics using a 555-timer–based circuit, and implemented this on a custom PCB to improve reliability and portability. I also helped with the mechanical design of the housing in SolidWorks that allowed patients to easily wear the device while ensuring durability and accessibility to the control knob and speaker.To evaluate the prototype, we conducted user testing with healthy participants to measure gait synchronization, multitasking performance, and usability. Analysis of video data showed strong alignment between foot strikes and metronome beats, supporting the device’s potential as a low-cost, user-friendly intervention for gait rehabilitation.\nThis project gave me hands-on experience in PCB design, 3D mechanical design, and human-centered testing, as well as insight into how engineering principles can translate into meaningful biomedical solutions. Find our final report here for more detail on our research, methods, and design!\n\n\nElectromyogram Sensing Circuit\n\nIn ENGR84: Electronic and Magnetic Circuits and Devices, I worked on a team project to design and build an electromyogram (EMG) circuit for measuring electrical activity in the bicep during muscle contraction. The goal was to capture the millivolt-level signals produced by skeletal muscle and process them into a readable output using amplifiers and filters.\nOur design used an instrumentation amplifier with an offset stage to safely amplify the input signals, followed by a bandpass filter to isolate relevant frequencies. We simulated the circuit, then implemented and tested it on a breadboard, troubleshooting challenges such as AC vs. DC coupling, amplifier rail limits, and loading effects, troubleshooting with design modifications like dual-rail powering and buffering.\nThis project strengthened my skills in analog circuit design, simulation, breadboarding, and troubleshooting, while giving me practical experience applying instrumentation amplifiers, filters, and signal conditioning concepts to biomedical signals. Find more details about this project in our report here.\n\n\nRF Oscilloscope Cable Fixture\n\nIn ENGR4: Introduction to Engineering Design and Manufacturing, I worked on a team project to design and build a shelf system to support long coaxial cables for the time domain reflectometry (TDR) experiments in the HMC RF course. The goal was to stabilize cable connection points, minimize strain on connectors, and improve the accuracy of oscilloscope measurements, all within the space constraints of a lab bench.\nWe iterated through several prototypes before finalizing a wooden shelf model with eight BNC passthrough mounts on one side. I contributed to the design and construction process in the HMC Wood Shop, where we built the structure, waterproofing the wood to prevent conductivity issues and reinforcing the shelves to hold the weight of up to 50 feet of cable. We carefully considered ergonomics, ensuring that shelves were spaced to allow hand access for connecting and disconnecting cables. Through evaluation with our client, the prototype proved stable, non-conductive, and able to support heavy cable loads without disrupting signals.\nThis project strengthened my skills in rapid iterative prototyping, hands-on manufacturing, and client-driven design, while showing me how thoughtful engineering can improve both usability and experimental accuracy. It also introduced me to the open-ended, team-based nature of engineering design problems and to foundational concepts in design theory, manufacturing methods, project management, and engineering ethics. Find our final report memo here!\n\n\nMachine Shop\nI’ve been a machine shop proctor for over 4 semesters now! As a proctor, I ensure that all users (5C students and professors) are safe and feel supported in their machining projects. I provide design and manufacturing advice/help to users in the metal and wood shops, which means I have a lot of experience operating mills, lathes, bandsaws, sanders, and more! ENGR4 students are some of the most popular users, as they make a hammer from scratch following tight tolerances. Other users include Engineering Clinic students who are solving creative and challenging problems for their clients, as well as users pursuing a variety of personal projects!\nI also spend a lot of time in the machine shop working on my own projects, which have ranged from things for courses (ENGR4 hammer and clinic) to gifts for friends! Below are some pictures of some of my projects (wooden pen, metal ring, my hammer!)."
  },
  {
    "objectID": "industry/index.html",
    "href": "industry/index.html",
    "title": "Industry Experiences",
    "section": "",
    "text": "The summer after my junior year, I worked at Honeywell Aerospace as an Electrical Engineering Intern, where I contributed to the redesign of the TR-1 weather radar. The TR-1 is a legacy airborne weather radar system that Honeywell is modernizing to improve performance and manufacturability, and my role focused on the transmitter/receiver module—the heart of the system responsible for generating and amplifying the RF signals that drive the radar. Because the performance of the transmit chain directly determines detection accuracy and reliability, validating and optimizing its design was a critical part of the project.\n\nI led RF test setup and waveguide fixture assembly to support transmit/receive module validation. This involved designing and assembling test fixtures, integrating waveguide components, and ensuring stable and repeatable measurement conditions in the lab. Much of my time was spent troubleshooting and optimizing the power amplifier, which is the most crucial component in the chain. Alongside this work, I programmed and controlled digital potentiometers used to fine-tune amplifier biasing, which gave me hands-on experience bridging hardware and software in a high-frequency system.\nI also used ANSYS HFSS simulations to improve the performance of waveguide transitions and rotary joints on the drive antenna. These joints must reliably pass high-power RF signals while rotating during operation, making them particularly sensitive to design tolerances and vendor part variations. Through careful modeling and parameter sweeps, I optimized designs to improve return loss and reduce the risk of mismatch across frequency bands. This work not only improved efficiency but also increased the robustness of the design against manufacturing variability—an important consideration in aerospace applications.\n\nThis internship gave me the chance to bridge theory and practice in RF and microwave engineering. I strengthened my skills in high-frequency test and measurement, electromagnetic simulation, programmable hardware, and waveguide component design, while also learning how to integrate electrical, mechanical, and manufacturing considerations into a single system. Most importantly, I gained experience working in an industry environment where performance margins are tight and reliability is paramount, preparing me for future roles at the intersection of RF engineering and systems integration."
  },
  {
    "objectID": "industry/index.html#honeywell-aerospace-technologies",
    "href": "industry/index.html#honeywell-aerospace-technologies",
    "title": "Industry Experiences",
    "section": "",
    "text": "The summer after my junior year, I worked at Honeywell Aerospace as an Electrical Engineering Intern, where I contributed to the redesign of the TR-1 weather radar. The TR-1 is a legacy airborne weather radar system that Honeywell is modernizing to improve performance and manufacturability, and my role focused on the transmitter/receiver module—the heart of the system responsible for generating and amplifying the RF signals that drive the radar. Because the performance of the transmit chain directly determines detection accuracy and reliability, validating and optimizing its design was a critical part of the project.\n\nI led RF test setup and waveguide fixture assembly to support transmit/receive module validation. This involved designing and assembling test fixtures, integrating waveguide components, and ensuring stable and repeatable measurement conditions in the lab. Much of my time was spent troubleshooting and optimizing the power amplifier, which is the most crucial component in the chain. Alongside this work, I programmed and controlled digital potentiometers used to fine-tune amplifier biasing, which gave me hands-on experience bridging hardware and software in a high-frequency system.\nI also used ANSYS HFSS simulations to improve the performance of waveguide transitions and rotary joints on the drive antenna. These joints must reliably pass high-power RF signals while rotating during operation, making them particularly sensitive to design tolerances and vendor part variations. Through careful modeling and parameter sweeps, I optimized designs to improve return loss and reduce the risk of mismatch across frequency bands. This work not only improved efficiency but also increased the robustness of the design against manufacturing variability—an important consideration in aerospace applications.\n\nThis internship gave me the chance to bridge theory and practice in RF and microwave engineering. I strengthened my skills in high-frequency test and measurement, electromagnetic simulation, programmable hardware, and waveguide component design, while also learning how to integrate electrical, mechanical, and manufacturing considerations into a single system. Most importantly, I gained experience working in an industry environment where performance margins are tight and reliability is paramount, preparing me for future roles at the intersection of RF engineering and systems integration."
  },
  {
    "objectID": "industry/index.html#intellisense-systems-inc.",
    "href": "industry/index.html#intellisense-systems-inc.",
    "title": "Industry Experiences",
    "section": "Intellisense Systems Inc. ",
    "text": "Intellisense Systems Inc. \n\nThe summer after my sophomore year, I worked at Intellisense Systems Inc. as an R&D Engineering Intern, where I helped design a nondestructive, automated inspection system for bearings. During development, bearing elements are prone to scratches, scuffs, and even holes. The existing inspection system for these elements was manual. In order to reduce cost, inspection time, and labor-intensive testing, Intellisense was in the early stages of developing a solution to detect surface flaws and interior voids in bearing elements of different shapes and sizes using visible band and terahertz (THz) imaging. My role was to assist on the component-level and whole system design.\n\nI originally conceptualized, designed, and prototyped a tray to hold various shapes and sizes of bearings, ensuring the tray aligned with the optical imaging constraints. This involved deep research and understanding of the imaging technology and material properties of the bearings. I also contributed to the design of the entire optomechanical system which, after rapid design iterations and prototyping, ended up being a robotic configuration. I designed linear and rotary stages, multiple-axis robotic arms, and robotic gripper configurations to hold the various-sized bearings. I performed cost and complexity analyses on multiple robotic system configurations, ensuring that all sizes and shapes of bearings could be imaged. This consisted of complex SolidWorks design, a detailed CAD assembly, and modeling of motion. I also helped the team research and get quotes for off the shelf robotic solutions. I also designed, rapid prototyped, and constructed mounting and bracketing solutions for various imaging technology within this system. Additionally, I also designed an adjustable focus telescope, consisting of collimating lenses, for the THz imaging.\nI gained a multitude of technical skills in this internship, from more experience in Solidworks to large system mechanical design and robotics. I also left this internship with a deeper understanding of how to succeed in an R&D environment, gaining firsthand experience in iterative design and learning how to engage in productive, technical design conversations."
  }
]